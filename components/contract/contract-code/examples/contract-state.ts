// State type definition
//
// The contract should define a single State interface type.
// The transpiler should generate the schema for the SDK to be used to create JS state object to access IAVL store.
// Each property could be either:
// - Item<T>, where T could be any typescript type. This will allocate a single Item inside the IAVL tree.
// - Map<T, U>, where T could be one of allowed typescript types(number, bigint, Address, string, etc.) and U could be another Item or Map.
import { Item, Map } from '~hyperweb/state';
import { Token } from '~hyperweb/token';
import * as token from '~hyperweb/token'; // see issue #56
export interface State {
	reserve0: Item<Token>;
	reserve1: Item<Token>;
	liquidityTokenDenom: Item<string>;

	// Note: these lines are technically not needed as the token package is handling accounting,
	// but it is still defined here to show how state variables works.
	liquidityTokenSupply: Item<Token>;
	liquidityProvided: Map<Address, Token>;
}

// Event definition
//
// Events could be emitted via calling ~hyperweb/std.emit(), which takes any JSON-serializable type.
// However, the developer can still write type definition to enforce safety.
// When emit is called, it will add events to the sdk.Context as a list of EventAttributes.
// See issue #59
type Event =
	| { kind: 'swap'; caller: Address; tokenIn: Token; tokenOut: Token }
	| { kind: 'addLiquidity'; caller: Address; token0: Token; token1: Token; shares: Token }
	| {
			kind: 'removeLiquidity';
			caller: Address;
			shares: Token;
			token0: Token;
			token1: Token;
	  };

// Contract definition
//
// Any class that is being default exported will be recognized as the contract.
import { Context, BaseContract, Address, instantiate, emit } from '~hyperweb/std';
export default class Contract extends BaseContract {
	private ctx: Context;
	private state: State;

	// constructor
	//
	// constructor has the same semantics with Typescript and does not serve the role of Instantiate.
	// When the contract is invoked the SDK will call new Contract(ctx, state) to create the contract instance it will interact with.
	// The ctx is the equivalent of sdk.Context, which holds runtime information such as block time, address of this contract, etc.
	// The constructor should take the state object(which has the property layout as defined in the interface State) and store it.
	constructor(ctx, state) {
		super(ctx);
		this.ctx = ctx;
		this.state = state;
	}

	// Other properties
	//
	// The contract can have properties just like other Typescript values and the behavior will be remain same.
	// Note that none of the properties of the contract are actually stored in the IAVL state; the state object is the interface to it.
	private CONTRACT_TITLE = 'Test AMM contract';
	public contractDescription =
		'This contract is a test AMM for demoing the capability of JSD, and a reference for contract convention';

	// instantiate
	//
	// instantiate method defines the one-shot function that will be executed when the contract is deployed.
	// Any method that has @instantiate decorator will be recognized as the instantiate method(regardless of the name).
	// The concrete implementation is provided later.
	@intantiate
	public instantiate(token0: string, token1: string) {
		const liquidityTokenDenom = `${token0}_${token1}`;
		this.state.liquidityTokenDenom = liquidityTokenDenom;
		// token.create will create the token under the prefix of this contract's address, with given string as subdenom.
		token.create(liquidityTokenDenom);
		this.state.liquidityTokenSupply = new Token(liquidityTokenDenom, 0);
		this.state.reserves = [new Token(token0, 0), new Token(token1, 0)];
	}

	// Visibility
	//
	// If a method is defined with visibility 'private', the schema generated by the transpiler should not include the method.
	// The contract schema will define the publicly accessible interface of the contract.
	private mint(to: Address, amount: number) {
		token.mint(to, new Token(this.state.liquidityTokenDenom, amount));

		// State modification
		//
		// The state object has the `Item`s defined as getter/setter properties and `Map`s as Proxy objects.
		// The concrete implementation is provided later.
		this.state.liquidityProvided[to] += amount;
		this.state.liquidityTokenSupply += amount;
	}

	private burn(from: Address, amount: number) {
		token.burn(from, new Token(this.state.liquidityTokenDenom, amount));

		this.state.liquidityProvided[from] -= amount;
		this.state.liquidityTokenSupply -= amount;
	}

	private updateReserves(token0: Token, token1: Token) {
		this.state.reserve0 = token0;
		this.state.reserve1 = token1;
	}

	public swap(tokenIn: Token): Token {
		const isToken0 = tokenIn.denom === this.state.reserve0.denom;
		const isToken1 = tokenIn.denom === this.state.reserve1.denom;

		if (!isToken0 && !isToken1) {
			throw Error('invalid token');
		}

		let [reserveIn, reserveOut] = isToken0 ? [reserve0, reserve1] : [reserve1, reserve0];

		// BaseContract will define sender() and address() methods, which is initialized by the super(ctx)
		//
		// When invoking a contract, an optional `approval` could be submitted. This is equivalent to
		// - Cosmwasm's attatched payment, or
		// - (conceptually) pre-calling the Approve() function in solidity.
		// token.transfer() is executed only when if the approved spending is higher than the requested amount.
		token.transfer(this.sender(), this.address(), tokenIn);

		const amountInWithFee = (tokenIn.amount * 997) / 1000;
		const amountOut = (reserveOut.amount * amountInWithFee) / (reserveIn.amount + amountInWithFee);
		const tokenOut = new Token(reserveOut.denom, amountOut);

		token.transfer(this.address(), this.sender(), tokenOut);

		this.updateReserves(
			token.balance(this.address(), this.reserve0.denom),
			token.balance(this.address(), this.reserve1.denom),
		);

		emit({
			kind: 'swap',
			caller: this.sender(),
			tokenIn,
			tokenOut,
		});

		return tokenOut;
	}

	public addLiquidity(token0: Token, token1: Token): Token {
		if (token0.denom !== this.state.reserve0.denom) {
			throw Error('invalid token');
		}
		if (token1.denom !== this.state.reserve1.denom) {
			throw Error('invalid token');
		}

		token.transfer(this.sender(), this.address(), token0, token1);

		const liquidityTokenSupply = this.state.liquidityTokenSupply;
		const reserve0 = this.state.reserve0.amount;
		const reserve1 = this.state.reserve1.amount;
		if (reserve0 * token1.amount !== reserve1 * token0.amount) {
			throw Error('invalid liquidity');
		}

		let shares = 0;
		if (liquidityTokenSupply > 0) {
			shares = Math.sqrt(token0.amount * token1.amount);
		} else {
			shares = Math.min(
				(token0.amount * liquidityTokenSupply) / reserve0,
				(token1.amount * liquidityTokenSupply) / reserve1,
			);
		}

		this.mint(this.sender(), shares);

		this.updateReserves(
			token.balance(this.address(), this.reserve0.denom),
			token.balance(this.address(), token.reserve1.denom),
		);

		const shareToken = new Token(this.state.liquidityTokenDenom, shares);

		emit({
			kind: 'addLiquidity',
			caller: this.sender(),
			token0,
			token1,
			shares: shareToken,
		});

		return shareToken;
	}

	public removeLiquidity(shares: number): [Token, Token] {
		const denom0 = this.state.reserve0.denom;
		const denom1 = this.state.reserve0.denom;

		const balance0 = token.balance(this.address(), denom0).amount;
		const balance1 = token.balance(this.address(), denom1).amount;

		const amount0 = (balance0 * shares) / this.state.liquidityTokenSupply;
		const amount1 = (balance1 * shares) / this.state.liquidityTokenSupply;

		this.burn(this.sender(), shares);
		this.updateReserves(new Token(denom0, balance0 - amount0), new Token(denom1, balance1 - amount1));

		const removed0 = new Token(denom0, amount0);
		const removed1 = new Token(denom1, amount1);
		token.transfer(this.address(), this.sender(), removed0, removed1);

		emit({
			kind: 'removeLiquidity',
			caller: this.sender(),
			shares,
			token0: removed0,
			token1: removed1,
		});

		return [removed0, removed1];
	}
}
